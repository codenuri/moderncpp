// array_pointer2.cpp
#include <stdio.h>

int main()
{
	int x[3] = {1,2,3};

	int* p1      = &x[0]; // 배열의 1번째 요소의 주소
	int (*p2)[3] = &x;    // 배열의 주소

	// p1, p2 는 현재 동일주소 입니다. 그런데, 타입이 다릅니다.
	// 포인터에 어떤 연산을 하면 "타입" 에 맞게 연산됩니다.
	printf("%p, %p\n", p1, p1 + 1); // 100, 104
	printf("%p, %p\n", p2, p2 + 1); // 100, 112


	// * 와 [ 연산도 결국 포인터의 타입에 따라 달라 집니다
	*p1 = 10; // *(int*) => int = 10;  // ok
	*p2 = 10; // *(배열*) => 배열 = 10; // error
	(*p2)[0] = 10; // *(배열*)[0] => 배열[0] = 10; // ok

	// [] 는 * 와 동일하므로
	*p1 = 10;   // ok
	p1[0] = 10; // ok
	(*p2)[0] = 10; // ok

	// 결론, 배열 x 를 포인터를 사용해서 모든 요소를 접근할때
	// => 1번째 요소를 가리키는 포인터 p1 이 있다면 x와 p1 의 사용법 동일
	// => 하지만 배열의 주소(p2) 를 사용하면 x와는 사용법이 달라 진다.
	//    *p2 해야, 배열이 된다. 따라서 p2[0] 이 아닌 (*p2)[0] 이 된다.

}











